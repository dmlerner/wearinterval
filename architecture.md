WearInterval: Production Architecture Specification1. Overview & Core PrinciplesThis document specifies the software architecture for the WearInterval application. The chosen architecture is a robust, multi-layered Model-View-ViewModel (MVVM) + Repository pattern. This choice is deliberate, ensuring that every major feature domain has its own dedicated repository and each screen has its own dedicated ViewModel.This approach prioritizes long-term maintainability, scalability, and testability over minimizing initial development effort. The goal is to create a production-quality codebase that is resilient, easy to debug, and capable of evolving without accumulating significant technical debt.Core Architectural PrinciplesSeparation of Concerns (SoC): Each component has a single, well-defined responsibility. This is paramount on resource-constrained devices like watches. For example, the TimerService is solely focused on timekeeping, freeing the UI layer to focus exclusively on rendering state. This strict separation prevents complex classes that are difficult to understand, test, and maintain.UI Layer: Displays data via Composables and captures user input. It is intentionally kept "dumb" and delegates all logic to ViewModels.ViewModels: Handle UI logic, manage UI state, and act as a bridge between the UI and the Domain layer.Repositories: Manage domain-specific data and orchestrate business logic, abstracting the data sources.Data Sources: Handle the low-level work of data persistence (Room, DataStore) and execution (Service).Unidirectional Data Flow (UDF): State flows in one direction, making the application's behavior predictable and easy to trace.State Flow: Repositories expose data via Kotlin StateFlow. ViewModels transform and combine these flows into a UiState object, which is then observed by the UI.Event Flow: The UI captures user interactions (e.g., a button click) and sends them upwards as events to the ViewModel (e.g., viewModel.onPlayPauseClicked()).Example Cycle: A user taps "Pause" -> MainScreen calls mainViewModel.pauseTimer() -> MainViewModel calls timerRepository.pauseTimer() -> TimerRepository sends a command to TimerService -> TimerService updates its internal state and emits a new TimerState -> TimerRepository's StateFlow emits the new state -> MainViewModel's UiState is re-calculated and emitted -> MainScreen recomposes to show a "Paused" state.Single Source of Truth (SSoT): Repositories are the definitive source of truth for their respective data domains. There is never ambiguity about where data comes from. For instance, the ConfigurationRepository is the only place the app can get the current timer settings. This prevents state synchronization bugs, where different parts of the UI might show conflicting information.Dependency Injection (DI): Hilt will be used to manage dependencies throughout the application. This decouples classes from their concrete dependencies, making them easier to test and reuse. Hilt also simplifies Android lifecycle management by providing correctly scoped instances of objects (e.g., @Singleton, @ViewModelScoped).Testability: The architecture is designed to be testable from the ground up, following the "testing pyramid" model. We can write fast, reliable unit tests for the majority of our logic (ViewModels, Repositories) without needing an emulator, and reserve slower, more complex instrumentation tests for validating the UI and end-to-end flows.2. System Architecture OverviewThe application is divided into three distinct, decoupled layers: UI, Domain, and Data. This layered approach ensures that changes in one part of the system (e.g., swapping the database implementation) have minimal impact on the others.┌─────────────────────────────────────────────────────────────────┐
│                           UI Layer                              │
│ (Compose for Wear OS, Navigation, Activities, ViewModels)       │
├─────────────────┬─────────────────┬─────────────────┬───────────┤
│   MainScreen    │  ConfigScreen   │ HistoryScreen   │ Settings  │
│   MainViewModel │ ConfigViewModel │HistoryViewModel │SettingsVM │
└─────────┬───────┴─────────┬───────┴─────────┬───────┴─────┬─────┘
          │ (Events Up)     │                 │             │ (State Down)
          └─────────────────┼─────────────────┼─────────────┘
                            │                 │
┌───────────────────────────▼─────────────────▼─────────────────────┐
│                       Domain Layer                                │
│ (Repositories: Business Logic & Data Coordination)              │
├─────────────────┬─────────────────┬─────────────────┬─────────────┤
│ TimerRepository │ConfigRepository │ SettingsRepo    │ WearOsRepo  │
└─────────┬───────┴─────────┬───────┴─────────┬───────┴─────┬───────┘
          │ (Commands Down) │                 │             │ (Data Up)
          └─────────────────┼─────────────────┼─────────────┘
                            │                 │
┌───────────────────────────▼─────────────────▼─────────────────────┐
│                         Data Layer                                │
│ (Data Sources: Services, Database, APIs, Preferences)           │
├─────────────────┬─────────────────┬─────────────────┬─────────────┤
│  TimerService   │  DataStore      │  Room Database  │ Wear OS APIs│
│ (Foreground)    │ (Preferences)   │ (History)       │(Tiles/Comps)│
└─────────────────┴─────────────────┴─────────────────┴─────────────┘

Data flows from the Data Layer up to the Domain Layer, where Repositories process and centralize it. The UI Layer's ViewModels then consume this data, prepare it for display, and expose it to the Composables. User actions trigger events that flow back down this chain, initiating state changes.3. Detailed Layer Breakdown3.1. UI LayerThis layer is exclusively concerned with presenting state to the user and capturing their input. It contains no business logic.Technology: Jetpack Compose for Wear OS will be used for building all UI components, leveraging its declarative nature for state-driven UIs. We will use components from the androidx.wear.compose.material library.Navigation: Navigation will be handled by androidx.wear.compose.navigation.SwipeDismissableNavHost, the standard for Wear OS, allowing for intuitive swipe-to-dismiss gestures.Activity: A single MainActivity annotated with @AndroidEntryPoint will serve as the application's entry point and host the NavHost and all Composable screens.Screens & ViewModels:Main Screen:Composable: MainScreen.kt - Renders the primary timer interface, including the dual progress rings and control buttons. It will be stateless, receiving all data and event handlers from the ViewModel.ViewModel: MainViewModel.kt - A key orchestrator that uses StateFlow.combine to merge streams from TimerRepository, ConfigurationRepository, and SettingsRepository into a single, cohesive MainScreenUiState object.State: data class MainScreenUiState - A comprehensive data class representing everything needed to draw the main screen.Right Config Screen (Picker):Composable: ConfigScreen.kt - Features three Picker Composables for laps, work, and rest duration.ViewModel: ConfigViewModel.kt - Manages the state of the pickers, including the list of options and the currently selected index. It communicates any changes immediately to the ConfigurationRepository.State: data class ConfigScreenUiStateLeft Config Screen (History):Composable: HistoryScreen.kt - Displays a ScalingLazyColumn with the last 4 used timer configurations.ViewModel: HistoryViewModel.kt - Fetches the list of recent configurations from ConfigurationRepository and exposes it. Handles the user tapping a historical item, triggering a call to configurationRepository.selectRecentConfiguration().State: data class HistoryScreenUiStateSettings Screen:Composable: SettingsScreen.kt - A 2x2 grid of ToggleButton Composables for the various notification settings.ViewModel: SettingsViewModel.kt - Manages the boolean state of each toggle and communicates changes to the SettingsRepository.State: data class SettingsScreenUiState3.2. Domain Layer (Repositories)Repositories are stateless components (@Singleton) that manage business logic and act as mediators between the ViewModels and the Data Layer.TimerRepository:Responsibility: Manages the live state of the timer. It is the sole component that interacts with TimerService, abstracting away the complexities of service binding and communication.API:val timerState: StateFlow<TimerState>: Exposes the current state of the timer, sourced directly from the TimerService.fun startTimer(): Gets the current configuration from ConfigurationRepository and passes it to the TimerService to begin the countdown.fun pauseTimer(), fun resumeTimer(), fun stopTimer(), fun dismissAlarm(): These methods directly translate user intent into commands for the TimerService.ConfigurationRepository:Responsibility: Manages the creation, persistence, and retrieval of TimerConfiguration objects. It intelligently routes requests to the correct data source.API:val currentConfiguration: StateFlow<TimerConfiguration>: Exposes the currently active configuration, sourced from DataStore.val recentConfigurations: StateFlow<List<TimerConfiguration>>: Exposes the last 4 used configurations, sourced from the Room database.suspend fun updateConfiguration(config: TimerConfiguration): Persists the new configuration to DataStore.suspend fun selectRecentConfiguration(config: TimerConfiguration): Sets a historical configuration as the current one by updating DataStore and also updates its lastUsed timestamp in Room.SettingsRepository:Responsibility: Manages all user-specific settings, abstracting the DataStore implementation.API:val notificationSettings: StateFlow<NotificationSettings>: Exposes the current settings from DataStore.suspend fun updateSettings(settings: NotificationSettings): Persists updated settings to DataStore.WearOsRepository:Responsibility: A critical abstraction layer that decouples the application's core logic from platform-specific APIs. This makes the app more modular and easier to adapt to future changes in the Wear OS Tile or Complication APIs.API:suspend fun updateWearOsComponents(): A single entry point to request updates for all relevant tiles and complications.suspend fun getTileData(): Fetches the current TimerState and recent configurations to build a TileData object for the TimerTileService.suspend fun getComplicationData(type: ComplicationType): Fetches the current TimerState to build a ComplicationData object for the TimerComplicationService.3.3. Data LayerThis layer contains the concrete sources of data and state, including services, databases, and platform APIs.TimerService.kt:Type: A foreground Service with a persistent notification, ensuring the timer can run reliably for long durations without being killed by the OS.Functionality: Contains the core countdown logic using a Job within a service-scoped CoroutineScope. Manages its own internal state machine (RUNNING, PAUSED, etc.) and exposes its current state via a public StateFlow. It is responsible for acquiring and releasing a PowerManager.WakeLock to keep the CPU active during a session.Communication: The TimerRepository will bind to this service using bindService() to send commands and observe its state flow.Jetpack DataStore:Library: androidx.datastore:datastore-preferencesUsage: For storing the NotificationSettings and the currentConfiguration. It is the modern replacement for SharedPreferences, offering asynchronous, transactional, and type-safe data persistence.Room Database:Library: androidx.room:room-runtime, androidx.room:room-ktxUsage: For storing the history of used TimerConfiguration objects. Room provides a robust, compile-time-verified abstraction over a local SQLite database.Components:@Entity data class TimerConfigurationEntity: The database table schema.@Dao interface ConfigurationDao: The data access object defining all database operations (queries, inserts).@Database abstract class AppDatabase: The main database holder, configured via Hilt.Wear OS APIs:Hardware: android.os.Vibrator and android.media.ToneGenerator will be wrapped in a dedicated NotificationManager helper class, which will be injected into the TimerService to handle haptic and audio feedback.Tiles: androidx.wear.tiles.TileService will be implemented to provide a custom tile.Complications: androidx.wear.watchface.complications.datasource.ComplicationDataSourceService will be implemented to provide data to watch faces.4. Core Data Models & State ManagementAll state-holding data classes will be immutable (val properties only) to ensure thread safety and predictable state management.data class TimerState: Represents the live state of the timer. Includes properties like phase: TimerPhase, timeRemaining: Duration, currentLap: Int, totalLaps: Int, isPaused: Boolean. The TimerPhase will be an enum: STOPPED, RUNNING, RESTING, PAUSED, ALARM_ACTIVE.data class TimerConfiguration: Represents a specific timer setup. Includes id: String, laps: Int, workDuration: Duration, restDuration: Duration, and lastUsed: Long.data class NotificationSettings: Represents user preferences: vibrationEnabled: Boolean, soundEnabled: Boolean, flashEnabled: Boolean, autoMode: Boolean.sealed class UiEvent: Represents all possible user actions that can modify state, providing a type-safe way to communicate from UI to ViewModel. Examples include PlayPauseClicked, StopClicked, LapsUpdated(newLapCount: Int), SelectHistoryItem(configId: String).The UDF cycle will be strictly enforced:UI Composable observes a StateFlow<UiState> from its ViewModel using collectAsStateWithLifecycle().User interacts with the UI (e.g., taps the play button).The Composable's event handler calls a function on the ViewModel (e.g., viewModel.onEvent(UiEvent.PlayPauseClicked)).The ViewModel, in a viewModelScope.launch block, processes the event and calls the appropriate Repository function(s).The Repository executes its business logic, interacts with Data Sources (e.g., sends a command to the TimerService), and updates its public StateFlow.The ViewModel's StateFlow (which is often a combine of repository flows) automatically receives the new data and emits a new UiState.The UI Composable, observing the flow, automatically and efficiently recomposes to reflect the new state.5. Wear OS Platform IntegrationsTiles (TimerTileService.kt):Library: androidx.wear.tilesImplementation: The service's onTileRequest will query the WearOsRepository for data. It will use TimelineBuilders.Timeline to provide a layout.Stopped State: A layout using LayoutElementBuilders.Grid to show the most recent TimerConfiguration objects. Each item will have a Modifiers.Clickable that launches the main activity with an intent containing the selected configuration ID.Running State: A layout using LayoutElementBuilders.Arc and LayoutElementBuilders.ProgressBar to show interval progress, along with tappable icons for pausing or stopping.Complications (TimerComplicationService.kt):Library: androidx.wear.watchface.complications.datasourceImplementation: The onComplicationRequest method will query the WearOsRepository and use a when statement on the ComplicationType to build and return the appropriate ComplicationData object (e.g., ShortTextComplicationData.Builder, RangedValueComplicationData.Builder).Permissions:The AndroidManifest.xml must declare:<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />: Required on API 33+ to show the foreground service notification. The app must request this permission at runtime.<uses-permission android:name="android.permission.WAKE_LOCK" />: To allow the TimerService to keep the CPU awake.<uses-permission android:name="android.permission.VIBRATE" />: To provide haptic feedback.The foreground service declaration with android:foregroundServiceType="shortService".6. Dependency Injection with HiltLibrary: com.google.dagger:hilt-androidSetup: An @HiltAndroidApp custom Application class is the entry point for Hilt. The MainActivity and TimerService will be annotated with @AndroidEntryPoint.Modules:@Module @InstallIn(SingletonComponent::class) RepositoryModule: Contains @Binds functions to bind repository interfaces (e.g., TimerRepository) to their concrete implementations (e.g., TimerRepositoryImpl).@Module @InstallIn(SingletonComponent::class) DataModule: Contains @Provides functions to provide singleton instances of the Room database, DAOs, and the DataStore PreferenceDataStore.Usage: ViewModels will be annotated with @HiltViewModel and have their repository dependencies injected via the constructor. Repositories and other classes will use @Inject constructor.7. Comprehensive Testing StrategyA rigorous, multi-layered testing strategy is essential for ensuring production quality and preventing regressions.Unit Tests:Location: src/test/javaFrameworks: JUnit5, MockK for mocking dependencies, Turbine for testing StateFlow emissions concisely.Targets:ViewModels: Given a specific state from mock repositories, when an event is received, assert that the ViewModel emits the correct new UiState. Test all UI logic branches.Repositories: Given a specific state from mock data sources (DAOs, Service), when a method is called, assert that the correct interactions with the data sources occur and that the repository's state flow is updated correctly.Integration Tests:Location: src/androidTest/javaFrameworks: AndroidX Test libraries (AndroidJUnit4), Room's inMemoryDatabaseBuilder to create a temporary, test-only database.Targets:DAOs: Write tests to verify that all SQL queries in the ConfigurationDao insert, retrieve, and delete data as expected.DataStore: Test that saving and retrieving settings and configurations works correctly.Instrumentation (UI) Tests:Location: src/androidTest/javaFrameworks: createComposeRule for interacting with Compose UI, Espresso for any View-based interactions if needed.Targets: Test end-to-end user flows. For example: "Launch the app, navigate to the config screen, change the lap count, navigate back, start the timer, and verify the UI shows the correct lap count." Use semantic finders (onNodeWithText, onNodeWithContentDescription) to interact with the UI.8. Detailed Implementation PlanThis plan breaks down the development process into logical, sequential phases, designed to build the app from the data layer up.Phase 1: Foundation & Core Models1.1. Project Setup: Create a new Wear OS project with Compose. Set minSdk to 30 (Wear OS 3.0) and compileSdk to 34 or higher.1.2. Add Dependencies: Add all necessary libraries for Hilt, Room, DataStore, Wear Compose Navigation, Coroutines, Turbine, and MockK to the build.gradle.kts file.1.3. Define Core Models: Create the immutable data classes: TimerState (with TimerPhase enum), TimerConfiguration, NotificationSettings, and the UiEvent sealed class. Add Parcelable implementation for passing configurations in Intents if needed.1.4. Hilt Setup: Create the WearIntervalApplication class and annotate it with @HiltAndroidApp. Create the empty Hilt modules (DataModule, RepositoryModule) in a di package.Phase 2: Data Layer Implementation2.1. Room Database: Implement the TimerConfigurationEntity, ConfigurationDao, and AppDatabase. Define TypeConverters for Duration if Room doesn't support it natively. Write and pass all DAO integration tests.2.2. DataStore: Create a wrapper class for DataStore to provide type-safe methods for reading and writing settings and the current configuration.2.3. Timer Service: Implement the basic structure of TimerService.kt. Include the binder, onStartCommand, the service-scoped CoroutineScope, and placeholder methods for timer logic. Define the service, its permissions, and foregroundServiceType in the AndroidManifest.xml.Phase 3: Domain Layer (Repositories)3.1. Implement Repositories: Create the interfaces and concrete implementations for SettingsRepository and ConfigurationRepository, connecting them to DataStore and Room. Write comprehensive unit tests for both, using mock data sources.3.2. Implement TimerRepository: Implement the TimerRepositoryImpl, including the ServiceConnection logic for binding/unbinding to the TimerService and observing its state.3.3. Implement WearOsRepository: Create the initial structure for the WearOsRepositoryImpl.Phase 4: UI & ViewModels4.1. Settings Screen: Build the SettingsScreen UI, SettingsViewModel, and connect them. This serves as a simple, complete vertical slice to validate the architecture.4.2. Config & History Screens: Build the ConfigScreen and HistoryScreen along with their respective ViewModels (ConfigViewModel, HistoryViewModel).4.3. Navigation: Set up the SwipeDismissableNavHost in MainActivity.kt and define the navigation graph with routes for all screens.4.4. Main Screen: Build the complex MainScreen UI and its MainViewModel. Use StateFlow.combine to merge data streams from the repositories into the single MainScreenUiState object.4.5. Connect Timer Logic: Wire the play/pause/stop buttons on the MainScreen to the TimerRepository via the MainViewModel. Implement the core countdown logic, state transitions, and wakelock management in the TimerService.Phase 5: Wear OS Integrations5.1. Implement TileService: Create TimerTileService.kt. Connect it to the WearOsRepository to render the tile based on the current TimerState. Test tile updates on an emulator.5.2. Implement ComplicationService: Create TimerComplicationService.kt. Connect it to the WearOsRepository to provide data for all complication types. Test on various watch faces.5.3. Foreground Notification: Implement a robust NotificationManager class responsible for creating and updating the TimerService's notification, including actions for play/pause/stop.Phase 6: Polishing, Testing & Refinement6.1. Write UI Tests: Implement instrumentation tests for the most critical user flows (e.g., configuring and running a full timer session).6.2. Haptics & Audio: Integrate vibration and sound feedback via the dedicated manager class in the TimerService.6.3. Edge Cases: Rigorously test and handle process death (using SavedStateHandle in ViewModels if necessary), runtime permission requests for notifications, and graceful degradation if hardware features are unavailable. Test what happens if the watch is restarted mid-session.6.4. Performance Optimization: Use the Android Profiler to check for recomposition issues, memory leaks, and excessive battery usage, particularly from the TimerService.6.5. Final Review: Perform a thorough code cleanup, add KDoc documentation to all public classes and methods, and conduct a final round of manual testing on a physical device.
